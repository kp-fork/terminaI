# **The Definitive Architecture for Enterprise Hybrid Automation: A Rust-Centric Approach to Governance, Legacy Interoperability, and Visual Fallback**

## **1\. Executive Strategic Analysis**

The enterprise automation landscape stands at a critical juncture, bifurcated
between two distinct but flawed paradigms: the brittle, coordinate-dependent
legacy of Robotic Process Automation (RPA) and the emergent, nondeterministic
promise of "Vision-Only" Large Action Models (LAMs). For mission-critical
environments—where financial transactions in SAP, patient records in Oracle
Forms, and global supply chain logistics in Win32 applications are
managed—neither extreme offers the necessary balance of reliability and safety.
The "Vision-Only" approach, while seductive in its generality, lacks the
pixel-perfect determinism and auditability required for strict governance.
Conversely, traditional RPA struggles with the dynamic rendering of modern web
interfaces and the "Citrix Gap," where the application Document Object Model
(DOM) is inaccessible behind a remote desktop stream.

This report articulates the architectural blueprint for a "Hybrid" Windows
Desktop Automation Agent designed to bridge this divide. The proposed system is
architected on a "Structure-First, Vision-Fallback" principle. This paradigm
prioritizes the interrogation of the underlying Operating System (OS)
accessibility trees—specifically Microsoft UI Automation (UIA) and the SAP
Scripting API—to identify controls deterministically. Only when these structural
bridges fail, such as within virtualized remote desktop environments or
non-standard rendering canvases, does the agent degrade gracefully to visual
analysis.

Furthermore, this architecture introduces a rigorous Governance Layer—the
"Safety Airbag." Unlike passive script runners that assume the validity of their
instructions, this agent utilizes kernel-level interception hooks to strictly
police actions before they are executed. By decoupling the execution logic from
the governance enforcement, the system ensures that no autonomous process can
violate defined operational policies, regardless of the intent generated by the
driving logic.

The following analysis synthesizes deep technical research into Windows
Component Object Model (COM) primitives, Rust-based systems programming,
enterprise security posture (EDR) compatibility, and legacy interoperability to
propose the "Golden Stack" for next-generation automation. The choice of Rust as
the systems core is deliberate; its memory safety guarantees and zero-cost
Foreign Function Interface (FFI) with the Windows API provide the low-latency
performance required to intercept user input without inducing system lag—a feat
unattainable with managed languages like C\# or interpreted environments like
Python.

## ---

**2\. The Core Foundation: Rust and the Windows API**

The foundational layer of a "Hybrid" Windows Automation Agent defines its
capabilities, reliability, and long-term maintainability. In the context of
enterprise software—where an agent must run continuously, interact with unstable
legacy applications, and enforce micro-second governance decisions—the choice of
programming language and API interaction strategy is paramount. The research
unequivocally points to **Rust** as the optimal systems language for the core
agent, orchestrated by **Node.js** for high-level logic and network IO. However,
simply choosing Rust is insufficient. The critical architectural differentiator
lies in _how_ Rust interacts with the Windows Operating System.

### **2.1 The Evolution of Windows Accessibility: From MSAA to UIA**

To build a robust agent, one must first understand the ground truth of Windows
accessibility APIs. The Windows ecosystem has evolved through two primary
frameworks. The legacy framework, Microsoft Active Accessibility (MSAA), was
introduced in the Windows 95 era and relies on the IAccessible COM interface.1
While revolutionary at the time, MSAA exposes a relatively flat list of elements
and lacks distinct support for modern control patterns, often failing to
distinguish meaningfully between complex widgets like a "Toggle Button" and a
standard "Push Button".1

This was superseded by the Microsoft UI Automation (UIA) framework, introduced
in Windows Vista. UIA utilizes the IUIAutomation COM interfaces and provides a
rich, unified object model that supports complex control patterns (e.g.,
InvokePattern, ValuePattern, GridPattern), sophisticated event listeners, and
property caching.1

For a modern "Hybrid" agent, the reality is that legacy applications (Win32,
Delphi, VB6) often only implement MSAA, while modern WPF and UWP applications
implement UIA. Crucially, the Windows operating system includes a built-in
"UIA-to-MSAA Proxy" that automatically translates legacy MSAA servers into UIA
elements.1 Therefore, the architectural imperative is to strictly target the
**UIA API**. The agent will perceive modern applications natively and legacy
Win32 apps via the system proxy, eliminating the need to maintain dual code
paths for MSAA and UIA unless dealing with extremely non-compliant legacy
implementations.

### **2.2 The Definitive Library: windows-rs vs. Wrappers**

The Rust ecosystem offers several approaches to consume UIA. The "Golden Stack"
decision process requires evaluating them against strict enterprise criteria:
stability, completeness, and overhead.

#### **2.2.1 The Wrapper Approach: uiautomation-rs**

The crate uiautomation-rs functions as a high-level wrapper around the Windows
UIA API.4 It provides a "Rust-idiomatic" interface, abstracting away much of the
COM complexity. However, research indicates that this crate is a convenience
layer rather than a comprehensive projection. It supports basic features such as
input, control, and patterns, but the documentation suggests it may not fully
expose the granular control necessary for complex enterprise scenarios, such as
specific CacheRequest tuning or the latest Windows 11 interfaces.4 In an
enterprise context, reliance on a wrapper introduces a "bus factor" and
dependency lag; if Microsoft releases a new UIA interface, the agent developers
must wait for the wrapper maintainer to update the crate.

#### **2.2.2 The Provider Abstraction: accesskit**

The accesskit crate appears in searches regarding Rust accessibility, but a
deeper analysis reveals its purpose is distinct. It is designed primarily to
_provide_ accessibility (i.e., making a Rust GUI framework like Egui or Druid
accessible to screen readers) rather than _consume_ it as an automation client.4
Using accesskit for an automation agent would be architecturally inverted and is
therefore rejected.

#### **2.2.3 The Official Projection: windows-rs**

The definitive choice for the "Golden Stack" is **windows-rs**.5 This crate is
the official language projection maintained by Microsoft. Unlike wrappers, it
generates Rust bindings directly from the Windows Metadata (WinMD) files,
ensuring 100% API coverage. If an API exists in the Windows SDK, it exists in
windows-rs.

The advantages of windows-rs are multifold:

- **Zero-Cost Abstraction:** It creates direct Foreign Function Interface (FFI)
  calls to the COM virtual tables. There is no overhead from intermediate
  abstraction layers, which is critical when processing thousands of UI elements
  in a loop.
- **Direct COM Access:** It allows the agent to instantiate IUIAutomation,
  IUIAutomationElement, and IUIAutomationCacheRequest directly using raw
  pointers and unsafe blocks, providing the developer with absolute control over
  the memory layout and object lifetime.5
- **Future-Proofing:** Updates to the crate align mechanically with the Windows
  SDK, removing the dependency on third-party maintainers to manually map new
  functions.

### **2.3 Implementing the UIA Client: Threading and Optimization**

The implementation of the UIA client using windows-rs involves specific patterns
to handle the COM Threading Model, which is a frequent source of bugs in
automation agents.

#### **2.3.1 The Threading Model: MTA vs. STA**

Windows COM objects exist within "Apartments." The UIA Client interfaces
(IUIAutomation) are generally thread-safe and designed to be initialized in a
**Multi-Threaded Apartment (MTA)**.5 This configuration allows the agent to make
API calls from any thread within the MTA, facilitating parallel processing.
However, a trap exists: some legacy event handlers or drag-and-drop operations
strictly require a **Single-Threaded Apartment (STA)**. The architectural
recommendation is for the Rust main thread (or the dedicated automation worker
thread) to initialize COM with CoInitializeEx(None, COINIT_MULTITHREADED) to
maximize throughput, while spawning distinct STA threads only when interacting
with legacy clipboard or drag-and-drop APIs.5

#### **2.3.2 Optimization: The CacheRequest Strategy**

A naive implementation of a UIA client walks the automation tree by requesting
elements one by one (e.g., getting a list of children, then querying the name of
the first child, then the second). This approach is disastrous for performance.
Each property access (like element.CurrentName()) triggers a cross-process
Inter-Process Communication (IPC) call to the target application. Fetching 100
items in a list view results in hundreds of round-trips, causing massive
latency.

The "Golden Stack" architecture must utilize **IUIAutomationCacheRequest**.7

1. **Definition:** The agent defines a "view" of the data it requires—for
   example, Name, ControlType, and BoundingRectangle.
2. **Execution:** This CacheRequest is passed to FindAll or GetElementFromPoint.
3. **Result:** Windows performs a _single_ IPC round-trip, fetches the entire
   subtree, populates the cache, and returns a proxy object to the Rust agent.
   Reading properties from this proxy is instantaneous as it accesses local
   memory.

This optimization is often impossible or difficult to implement in wrapper
libraries that abstract away the CacheRequest object, reinforcing the necessity
of windows-rs.

### **2.4 Architecture: The "Detached Worker" Model**

UIA calls are inherently synchronous and blocking. If the agent attempts to
inspect a window belonging to an application that is "Not Responding" (hung),
the UIA call will block the calling thread, potentially indefinitely or until a
long system timeout is reached. To prevent the entire Node.js/Rust agent from
freezing when encountering a hung Win32 app, the architecture must decouple the
UIA interaction.

**The Resilience Pattern:**

1. **Command Queue:** The Node.js layer pushes a command ("Click Button X") to a
   Rust Channel.
2. **Worker Pool:** A dedicated Rust thread pops the command.
3. **Timeout Wrapper:** The worker does _not_ call UIA directly on itself if
   there is a risk of a hang. Instead, for high-risk operations (like FindAll on
   a deep tree), it spawns a temporary closure or utilizes a timeout mechanism.
   - _Note:_ Since Rust threads cannot be forcibly killed safely (due to RAII
     destructors), the "Timeout" is often handled by identifying "hung" window
     handles using the IsHungAppWindow Win32 API _before_ attempting UIA
     interaction.
4. **Result:** The worker returns the result or an error to the Node.js layer
   via callback.

This ensures that the "Governance Layer" (discussed in Section 4\) and the
"Heartbeat" of the agent remain alive even if the automation target enters a
zombie state.

## ---

**3\. Bridging the Legacy Gap: SAP & Win32**

The "Structure-First" approach dictates that the agent must use the deepest,
most semantic API available for a given application. For two of the most common
enterprise targets—SAP GUI and legacy Win32 apps—generic UIA is often a
fallback, not the primary interface.

### **3.1 The SAP GUI Bridge**

SAP GUI for Windows is a notoriously difficult target for generic UIA. While SAP
exposes some elements to UIA, the hierarchy is often flattened or incomplete,
and performance is sluggish. The definitive solution is the **SAP GUI Scripting
API**, a COM-based automation interface provided specifically for this purpose.8
This API exposes the internal SAP object model, allowing for precise control
manipulation that bypasses the rendering layer entirely.

#### **3.1.1 Enabling the Bridge (The Governance Check)**

Unlike UIA, which is always available, SAP Scripting is typically locked down by
default in enterprise environments. The agent must verify that the environment
is correctly configured before attempting attachment. This involves a two-step
verification process:

1. **Server-Side Configuration:** The SAP Basis administrator must set the
   profile parameter sapgui/user_scripting to TRUE in transaction RZ11.8 This is
   a server-wide setting that allows the client to accept scripting connections.
2. **Client-Side Configuration:** The local SAP GUI client must also be
   configured to allow scripting. This is controlled via the Windows Registry.
   The key HKEY_LOCAL_MACHINE\\SOFTWARE\\SAP\\SAPGUI Front\\SAP Frontend
   Server\\Security\\UserScripting must be set to 1 (Enabled).11
   - _Operational Insight:_ Enabling this may trigger a notification to the user
     ("Scripting is trying to attach"). To enable fully silent automation, the
     registry value WarnOnAttach should be set to 0\.12 Note that changing these
     registry keys programmatically usually requires Administrator privileges,
     which the agent setup process should handle.

#### **3.1.2 Technical Implementation: IDispatch in Rust**

The SAP Scripting API exposes a distinct object hierarchy: GuiApplication \-\>
GuiConnection \-\> GuiSession \-\> GuiFrameWindow.9 The Rust agent uses
windows-rs (specifically the IDispatch interface) to interact with this dynamic
COM object.

**The Connection Sequence:**

1. **Get the ROT Entry:** The agent accesses the Running Object Table (ROT) to
   find an existing, active SAP GUI process. The call GetActiveObject("SAPGUI")
   returns the ISapGuiAuto interface wrapper.14
2. **The Engine:** The agent invokes the GetScriptingEngine() method on the
   application object.
3. **The Hierarchy:**
   - The agent iterates through Children to find the active connection (usually
     Children(0)).
   - From the connection, it retrieves the active session (usually
     Children(0)).14

The "Magic" of SAP IDs:  
Once the GuiSession is obtained, the agent no longer needs visual search or
fragile UIA scraping. It uses string-based IDs that are remarkably stable across
sessions and even some version upgrades.

- _Example ID:_
  /app/con/ses/wnd/usr/tabsTAXI_TABSTRIP_OVERVIEW/tabpT\\01/ssubSUBSCREEN_BODY:SAPMV45A:4400/subSUBSCREEN_TC:SAPMV45A:4900/tblSAPMV45ATCTRL_U_ERF_AUFTRAG
- _Mechanism:_ The agent implements a FindById(string_id) method wrapping the
  SAP COM call.15

Hybrid Switching Strategy:  
The agent must possess a "Context Awareness" module. When the active window
class is detected as SAP_FRONTEND_SESSION, the agent automatically swaps its
"Driver" from UIA_Driver to SAP_Driver. It exposes a unified API to the Node.js
layer (e.g., agent.type("\#username", "admin")), but internally, the SAP_Driver
executes session.FindById(".../txtBNAME").text \= "admin".

### **3.2 The Win32 Stability Problem**

Legacy Win32 applications (coded in C++, MFC, or VB6) pose a specific challenge:
**Dynamic UIA IDs**. In modern WPF apps, developers assign stable AutomationId
properties. In legacy Win32, the UIA AutomationId is often auto-generated at
runtime (e.g., based on the memory address or a random hash), making it useless
for persistent scripts.16

#### **3.2.1 The GetDlgCtrlID Solution**

The Windows API contains a mechanism from the 1990s that is the key to
stabilizing these apps: the **Dialog Control ID**. Every control in a standard
Win32 dialog has an integer ID assigned at compile time (defined in the .rc
resource file). This ID is generally constant across reboots and versions.

The Golden Algorithm:  
When the Rust agent inspects a Win32 window via UIA and finds no stable
AutomationId:

1. It retrieves the NativeWindowHandle property (an integer HWND) from the UIA
   element.
2. It passes this HWND to the GetDlgCtrlID Win32 function.17
3. If the result is non-zero, this Integer ID (e.g., 4096\) serves as a unique,
   stable identifier for that specific version of the application.

Selector Strategy:  
The agent's selector engine should support a "Legacy ID" strategy:  
"win32=title:'Invoice App' && ctrl_id:4096"  
This bypasses the flakiness of "Name" (which might change with localization) and
"AutomationId" (which might change with reboot), providing a high-entropy,
stable locator.18

## ---

**4\. The Governance Layer: "The Safety Airbag"**

In an enterprise environment, an automation agent acts as a high-privilege user.
If the logic layer (Node.js script) "hallucinates" or malfunctions, the agent
could theoretically delete data or transfer funds erroneously. The "Hybrid"
agent distinguishes itself by implementing a **Governance Layer** that is
architecturally separate from the execution logic. This layer acts as a "Safety
Airbag," intercepting every physical input event at the kernel level to validate
it against a Policy Engine _before_ the application receives it.

### **4.1 Global Input Hook Architecture**

To strictly control input, the agent cannot rely on simply "not calling the
click function." It must assume the role of a gatekeeper for the entire user
session, guarding against both its own automated actions and accidental user
interference during critical operations.

#### **4.1.1 Mechanism: SetWindowsHookEx**

The only API capable of this level of interception is SetWindowsHookEx,
specifically utilizing the hook types WH_MOUSE_LL (Low-Level Mouse) and
WH_KEYBOARD_LL (Low-Level Keyboard).19 These hooks are installed into the
Windows message chain. When a mouse event occurs (e.g., WM_LBUTTONDOWN), the
Operating System pauses the delivery of that event to the target window and
instead executes the hook's callback function.

#### **4.1.2 The Latency/Timeout Constraint**

This power comes with a critical constraint: **Responsiveness.** Windows
enforces a LowLevelHooksTimeout (typically default is around 300ms to 1000ms,
depending on the OS version).20 If the hook callback takes longer than this
timeout to return, the OS assumes the hooking application has hung and silently
removes the hook to unfreeze the mouse cursor. This behavior effectively
"breaks" the safety airbag.

**Implication:** The Rust hook callback must be effectively "Wait-Free." It
cannot perform complex logic, such as database lookups, HTTP calls, or complex
regular expression matching, inside the callback itself.

**The Rust Architecture for Hooks:**

1. **The Hook DLL:** A minimal Rust cdylib is loaded. It exports functions to
   install_hook() and uninstall_hook().
2. **The Callback:** The LowLevelMouseProc function in Rust captures the event
   data (MSLLHOOKSTRUCT). Crucially, it does _not_ process the data. It merely
   acts as a high-speed transmitter.

### **4.2 IPC Strategy: The Race Against Time**

The connection between the "Hook Callback" (interrupt context) and the "Policy
Engine" (User Mode logic) is the system bottleneck.

#### **4.2.1 Shared Memory vs. Named Pipes**

Research into IPC latency confirms that **Shared Memory** is the only viable
transport for this use case.22

- **Named Pipes:** Latency benchmarks indicate that Named Pipes can exhibit
  latencies ranging from 50µs to over 600µs.23 While fast for general data
  transfer, the variance (jitter) creates a "sticky mouse" feel for the user.
- **Shared Memory:** Latency is governed only by memory bus speed and
  synchronization primitives, typically remaining consistently in the sub-10
  microsecond range (\< 10µs).23

#### **4.2.2 The Ring Buffer Implementation**

The agent allocates a memory-mapped file (CreateFileMapping).

- **Structure:** A Ring Buffer (circular queue) of "Input Events."
- **Synchronization:** Named Event objects (CreateEvent) are used for signaling.
  - Event_DataReady: Signaled by the Hook when data is written.
  - Event_VerdictReady: Signaled by the Agent when a decision is made.

**The Transactional Flow:**

1. **Hook:** Write(Event) \-\> Signal(Event_DataReady) \-\>
   WaitForSingleObject(Event_VerdictReady, Timeout=5ms).
2. **Agent:** Wait(Event_DataReady) \-\> Read \-\> CheckPolicy(X,Y) \-\>
   Write(Verdict) \-\> Signal(Event_VerdictReady).
3. **Hook:**
   - If Verdict \== BLOCK: Return 1 (swallows the input).
   - If Verdict \== ALLOW: Call CallNextHookEx (input proceeds to app).
   - If Timeout: Fail-safe (usually ALLOW to prevent locking the user out, or
     BLOCK if in strict mode).

This architecture ensures the governance check happens in real-time, effectively
"air-gapping" the input from the application until it is vetted by the policy
engine.

### **4.3 The Policy Engine Logic**

The Policy Engine is the brain connected to the Hook's nervous system. It
maintains a cached "Map of Allowed Zones."

- _Input:_ WM_LBUTTONDOWN at (1920, 1080).
- _Logic:_ The agent checks its current state: "I am expecting a click on the
  'Submit' button."
- _Validation:_ It compares (1920, 1080\) against the BoundingRectangle of the
  'Submit' button (retrieved via UIA).
- _Outcome:_ If the click is within the box, ALLOW. If the click is on the
  'Cancel' button or outside the window, BLOCK.

## ---

**5\. Survival in the Hostile Enterprise: EDR Coexistence**

This architecture, while secure by design, mimics the behavior of sophisticated
malware (specifically Rootkits and Keyloggers). Enterprise Endpoint Detection
and Response (EDR) systems like CrowdStrike Falcon and SentinelOne are tuned to
flag SetWindowsHookEx usage aggressively.25 An unauthorized agent utilizing
global hooks will be terminated immediately.

### **5.1 Threat Landscape and EDR Behavior**

- **Keylogging Signature:** The use of WH_KEYBOARD_LL is a primary signature for
  keyloggers.26
- **Injection Heuristics:** Although Low-Level hooks technically execute the
  callback in the context of the installing thread (the agent), older hook types
  injected DLLs into every process. EDRs often flag global hooks as potential
  "Reflective DLL Injection" attempts or "Credential API Hooking".28
- **SentinelOne Specifics:** SentinelOne employs "Anti-Exploit" modules that
  specifically monitor for "Deep Hooks".29

### **5.2 The Allowlisting Strategy**

To deploy this agent without triggering a Security Operations Center (SOC)
incident, the following strategy is mandatory:

#### **5.2.1 EV Code Signing (Non-Negotiable)**

The agent binary and any helper DLLs must be signed with an **Extended
Validation (EV) Code Signing Certificate**. Unlike standard certificates, EV
certificates require rigorous identity verification of the publisher.
SmartScreen and EDR heuristics apply a massive "Trust Score" boost to EV-signed
binaries, often treating them as "Trusted Publishers" by default.30

#### **5.2.2 AppLocker Publisher Rules**

Reliance on path-based exclusions (e.g., excluding C:\\Program Files\\Agent) is
insecure and often ignored by strict EDR policies. The robust approach is to
leverage **AppLocker** (or Windows Defender Application Control).

- **Mechanism:** IT Administrators create a "Publisher Rule" that explicitly
  permits software signed by the agent's specific Certificate OID to run and
  perform privileged operations.32
- **EDR Inheritance:** Modern EDRs configured in "Co-existence" or
  "Productivity" modes often respect the OS's AppLocker allowlist, reducing the
  likelihood of false positives.

#### **5.2.3 Reputation Seeding**

New binaries are inherently suspect. Before widespread deployment, the signed
binary should be submitted to the Microsoft Security Intelligence portal for
analysis. This helps establish a "clean" reputation in the Microsoft SmartScreen
database, which is shared with Microsoft Defender ATP and other security tools.

#### **5.2.4 Fallback: Raw Input API**

If SetWindowsHookEx is strictly prohibited by policy, the agent must fallback to
the **Raw Input API** (RegisterRawInputDevices).34

- _Trade-off:_ Raw Input allows _monitoring_ input without triggering the same
  injection heuristics as hooks. However, it receives input asynchronously and
  largely in parallel with the target application. This means it cannot reliably
  _block_ input (the "Safety Airbag" becomes a passive "Black Box Recorder").
  For strict Governance, SetWindowsHookEx is the only "Golden" path; Raw Input
  is the fallback for "Auditing Only" modes.

## ---

**6\. The Vision Fallback: Handling the "Citrix Gap"**

When the agent encounters a Virtual Desktop Infrastructure (VDI) window (Citrix,
VMware Horizon, RDP) or a canvas-rendered application (Flutter, standard HTML5
Canvas), the UIA tree dissolves into a single opaque element. The
"Structure-First" architecture must gracefully degrade to "Vision."

### **6.1 High-Performance Capture: DXGI Desktop Duplication**

The standard GDI (BitBlt) capture used by older tools is too slow, causing high
CPU usage and screen tearing. The definitive stack uses **DXGI Desktop
Duplication**.35

- **Mechanism:** This API operates directly on the GPU, providing a texture
  containing the desktop image. This allows for zero-copy capture where the
  image data remains in VRAM until explicitly mapped.
- **Rust Implementation:** The agent utilizes the win_desktop_duplication crate
  or a direct windows-rs implementation of IDXGIOutputDuplication.
- **Efficiency:** The API supports "Dirty Rectangles." If only a small part of
  the screen updates (e.g., a blinking cursor), the API returns metadata
  indicating only that region needs processing. The agent should only run
  OCR/Vision on these dirty regions to conserve CPU.36

### **6.2 OCR Engine Showdown: Tesseract vs. Windows Media**

For the "Structure-First, Vision-Fallback" model, the goal of vision is
primarily **Text-to-Coordinate Mapping** (i.e., "Find the word 'Submit' so I can
click it").

#### **6.2.1 Tesseract**

- _Pros:_ Open source, cross-platform.
- _Cons:_ Heavy dependency (requires shipping Tessdata binaries), slow
  initialization, and requires significant image preprocessing (binarization,
  scaling) to achieve acceptable accuracy on screen fonts.37

#### **6.2.2 Windows.Media.Ocr**

- _Pros:_ Native to Windows 10/11 (WinRT). Zero distribution size (part of the
  OS). Hardware accelerated. Extremely high accuracy for screen fonts. Supports
  25+ languages out of the box.39
- _Cons:_ Windows only (which fits the constraints of this Windows-specific
  agent).

The Verdict:  
The "Golden Stack" uses Windows.Media.Ocr. Using the windows crate, the Rust
agent can interface with WinRT directly.

Rust

// Architectural Snippet: WinRT OCR in Rust  
use windows::Media::Ocr::OcrEngine;  
use windows::Graphics::Imaging::SoftwareBitmap;

// 1\. Create Engine (Cached)  
let engine \= OcrEngine::TryCreateFromUserProfileLanguages()?;

// 2\. Capture Frame (DXGI) \-\> Convert to SoftwareBitmap  
let bitmap \= convert_dxgi_to_bitmap(frame)?;

// 3\. Recognize  
let result \= engine.RecognizeAsync(\&bitmap)?.get()?;

// 4\. Map  
for line in result.Lines()? {  
 let text \= line.Text()?;  
 let rect \= line.BoundingRect()?; // Returns x, y, width, height  
 // Store in internal "Visual DOM"  
}

This process aligns the "Visual DOM" with the screen coordinates. When the
selector engine receives a query for "ocr='Submit'", it performs a spatial
lookup in this cached Visual DOM, bypassing the need for structure.

## ---

**7\. Reference Architectures & The Golden Stack**

To validate this architecture, we examine established players.

- **UiPath:** Uses a hybrid approach. For local apps, it uses UIA/COM. For
  Citrix, it deploys a "Remote Runtime"—a component installed on the remote
  server that communicates structure back to the client via a Virtual Channel,
  effectively "injecting" the agent into the remote stream.41 Without this
  remote component, it falls back to vision (Computer Vision AI).
- **Playwright:** Uses a WebSocket server (Node.js) and browser contexts. Its
  selector engine is notable for its "chained" logic (e.g., css=article \>\>
  text=Login). The Rust agent should adopt this "Selector Engine" concept,
  parsing a unified string syntax into the appropriate UIA or SAP query.43

### **7.1 The "Golden Stack" Summary**

The following table summarizes the definitive technical choices for the Hybrid
Agent.

| Component           | Technology Choice     | Justification                                                                            |
| :------------------ | :-------------------- | :--------------------------------------------------------------------------------------- |
| **Orchestrator**    | **Node.js**           | Fast iteration, rich ecosystem for networking/API, easy integration with frontend UIs.   |
| **System Core**     | **Rust**              | Memory safety, zero-cost FFI with Windows API, predictable latency for hooks.            |
| **UIA Library**     | **windows-rs**        | Official Microsoft projection. Access to raw COM interfaces (IUIAutomation, ICondition). |
| **SAP Bridge**      | **COM (SAPGUI.App)**  | Direct interaction with SAP Object Model. Bypasses unreliable visual scraping.           |
| **Win32 Stability** | **GetDlgCtrlID**      | Stabilizes dynamic automation IDs using legacy resource IDs.                             |
| **Safety Hook**     | **SetWindowsHookEx**  | The only mechanism to _block_ prohibited input. Implemented in Rust with unsafe FFI.     |
| **IPC (Hook)**      | **Shared Memory**     | Sub-10µs latency ring buffer to prevent LowLevelHooksTimeout and mouse lag.              |
| **Vision Capture**  | **DXGI Desktop Dup**  | GPU-based capture. win_desktop_duplication crate or direct IDXGIOutputDuplication.       |
| **OCR Engine**      | **Windows.Media.Ocr** | Native WinRT API. No extra dependencies, HW accelerated, high accuracy.                  |

### **7.2 The Unified Selector Engine**

The agent mimics the developer ergonomics of Playwright but adapts them to the
desktop reality.

**Selector Syntax Specification:**

- **Standard UIA:** text="Login", id="SubmitBtn".
- **Legacy Win32:** win32=\#3201 (where 3201 is the Dialog Control ID).
- **SAP:** sap=\#/app/con/... (Direct pass-through to SAP Bridge).
- **Vision:** ocr="Invoice Number" right-of "Date".

Resolution Logic:  
The Rust core implements a SelectorParser.

1. **Parse:** Identify prefix (sap=, uia=, ocr=).
2. **Context Check:** If sap=, check if GuiSession is active.
3. **UIA Search:** If uia=, use IUIAutomation::CreateAndCondition to build the
   query. Use FindFirst on the cached tree.
4. **Stable ID Fallback:** If UIA fails to find a dynamic ID, automatically
   search by GetDlgCtrlID (if Win32) or RuntimeId.
5. **Vision Fallback:** If structure search returns null and the policy allows,
   trigger a DXGI capture frame \+ OCR pass, then query the resulting "Visual
   DOM."

### **7.3 Hybrid SAP Strategy**

To reliably automate SAP without manual user configuration, the agent should
ideally operate in an environment where the "Server-Side" scripting parameter is
already enabled by IT policy. However, the agent must be robust enough to detect
the state.

1. **Detection:** Upon launching, check the Registry key UserScripting.
2. **Remediation (Admin):** If 0, and the agent has Admin rights, set to 1\.
3. **Attachment:** Use GetActiveObject("SAPGUI") to latch onto the existing
   session.
4. **Execution:** Translate high-level intent ("Type 4000 into Company Code")
   into the SAP ID string /app/con/ses/wnd/usr/ctxtBKPF-BUKRS and set the .text
   property directly via COM.

This architecture ensures the agent respects the proprietary object models of
the past while leveraging the speed and safety of Rust to handle the governance
requirements of the future. This "Golden Stack" represents the most robust,
secure, and maintainable path forward for enterprise desktop automation.

#### **Works cited**

1. UI Automation Overview \- Win32 apps \- Microsoft Learn, accessed December
   25, 2025,
   [https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-uiautomationoverview](https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-uiautomationoverview)
2. UI Automation Overview \- .NET Framework \- Microsoft Learn, accessed
   December 25, 2025,
   [https://learn.microsoft.com/en-us/dotnet/framework/ui-automation/ui-automation-overview](https://learn.microsoft.com/en-us/dotnet/framework/ui-automation/ui-automation-overview)
3. LegacyIAccessible Control Pattern \- Win32 apps \- Microsoft Learn, accessed
   December 25, 2025,
   [https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-implementinglegacyiaccessible](https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-implementinglegacyiaccessible)
4. Rust for windows uiautomation \- Crates.io, accessed December 25, 2025,
   [https://crates.io/crates/uiautomation](https://crates.io/crates/uiautomation)
5. windows-rs/crates/samples/windows/uiautomation/src/main.rs at master \-
   GitHub, accessed December 25, 2025,
   [https://github.com/microsoft/windows-rs/blob/master/crates/samples/windows/uiautomation/src/main.rs](https://github.com/microsoft/windows-rs/blob/master/crates/samples/windows/uiautomation/src/main.rs)
6. windows::UI::UIAutomation \- Rust, accessed December 25, 2025,
   [https://microsoft.github.io/windows-docs-rs/doc/windows/UI/UIAutomation/index.html](https://microsoft.github.io/windows-docs-rs/doc/windows/UI/UIAutomation/index.html)
7. IUIAutomationElement::FindAll (uiautomationclient.h) \- Win32 apps |
   Microsoft Learn, accessed December 25, 2025,
   [https://learn.microsoft.com/en-us/windows/win32/api/uiautomationclient/nf-uiautomationclient-iuiautomationelement-findall](https://learn.microsoft.com/en-us/windows/win32/api/uiautomationclient/nf-uiautomationclient-iuiautomationelement-findall)
8. How to Enable SAP GUI Scripting \- Leapwork, accessed December 25, 2025,
   [https://support.leapwork.com/s/article/HowtoEnableSAPGUIScripting63307dd860760](https://support.leapwork.com/s/article/HowtoEnableSAPGUIScripting63307dd860760)
9. SAP GUI Scripting API, accessed December 25, 2025,
   [https://help.sap.com/doc/9215986e54174174854b0af6bb14305a/770.08/en-US/sap_gui_scripting_api.pdf](https://help.sap.com/doc/9215986e54174174854b0af6bb14305a/770.08/en-US/sap_gui_scripting_api.pdf)
10. How to enable scripting in SAP GUI and other requirements \- FlowShare
    Documentation, accessed December 25, 2025,
    [https://support.getflowshare.com/en/articles/10097852-how-to-enable-scripting-in-sap-gui-and-other-requirements](https://support.getflowshare.com/en/articles/10097852-how-to-enable-scripting-in-sap-gui-and-other-requirements)
11. Technical steps to prepare for SAP GUI automation, accessed December 25,
    2025,
    [https://community.sap.com/t5/enterprise-resource-planning-blogs-by-members/technical-steps-to-prepare-for-sap-gui-automation/ba-p/13416396](https://community.sap.com/t5/enterprise-resource-planning-blogs-by-members/technical-steps-to-prepare-for-sap-gui-automation/ba-p/13416396)
12. Enabling and forcing SAP Gui Scripting Options \- SAP Community, accessed
    December 25, 2025,
    [https://community.sap.com/t5/technology-q-a/enabling-and-forcing-sap-gui-scripting-options/qaq-p/336729](https://community.sap.com/t5/technology-q-a/enabling-and-forcing-sap-gui-scripting-options/qaq-p/336729)
13. SAP GUI Scripting API 6.40 \- Process Runner Excel Add-in, accessed December
    25, 2025,
    [https://help.innowera.net/PR2008/2.00/SAP_Scripting_API.pdf](https://help.innowera.net/PR2008/2.00/SAP_Scripting_API.pdf)
14. Help with COM object in SAP \- AutoIt, accessed December 25, 2025,
    [https://www.autoitscript.com/forum/topic/40074-help-with-com-object-in-sap/](https://www.autoitscript.com/forum/topic/40074-help-with-com-object-in-sap/)
15. Scripting API doesn't work with SAPGUI 720 patch 3 \- SAP Community,
    accessed December 25, 2025,
    [https://community.sap.com/t5/technology-q-a/scripting-api-doesn-t-work-with-sapgui-720-patch-3/qaq-p/7361556](https://community.sap.com/t5/technology-q-a/scripting-api-doesn-t-work-with-sapgui-720-patch-3/qaq-p/7361556)
16. Best Practices For Creating Stable Selectors | by Luis Serna \- Medium,
    accessed December 25, 2025,
    [https://medium.com/@lsosvaldo/best-practices-for-creating-stable-selectors-00ddc5f07cc8](https://medium.com/@lsosvaldo/best-practices-for-creating-stable-selectors-00ddc5f07cc8)
17. GetDlgCtrlID function (winuser.h) \- Win32 apps \- Microsoft Learn, accessed
    December 25, 2025,
    [https://learn.microsoft.com/tr-tr/windows/win32/api/winuser/nf-winuser-getdlgctrlid](https://learn.microsoft.com/tr-tr/windows/win32/api/winuser/nf-winuser-getdlgctrlid)
18. Selecting Child Objects \- Win32 apps \- Microsoft Learn, accessed December
    25, 2025,
    [https://learn.microsoft.com/en-us/windows/win32/winauto/selecting-child-objects](https://learn.microsoft.com/en-us/windows/win32/winauto/selecting-child-objects)
19. SetWindowsHookExA function (winuser.h) \- Win32 apps \- Microsoft Learn,
    accessed December 25, 2025,
    [https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa)
20. LowLevelMouseProc callback function \- Win32 apps \- Microsoft Learn,
    accessed December 25, 2025,
    [https://learn.microsoft.com/en-us/windows/win32/winmsg/lowlevelmouseproc](https://learn.microsoft.com/en-us/windows/win32/winmsg/lowlevelmouseproc)
21. Performance (?) problem with low level Mouse Hook \- CodeGuru Forums,
    accessed December 25, 2025,
    [https://forums.codeguru.com/showthread.php?314361-Performance-(-)-problem-with-low-level-Mouse-Hook](<https://forums.codeguru.com/showthread.php?314361-Performance-(-)-problem-with-low-level-Mouse-Hook>)
22. IPC in Rust \- a Ping Pong Comparison, accessed December 25, 2025,
    [https://3tilley.github.io/posts/simple-ipc-ping-pong/](https://3tilley.github.io/posts/simple-ipc-ping-pong/)
23. Every request, every microsecond: scalable machine learning at Cloudflare,
    accessed December 25, 2025,
    [https://blog.cloudflare.com/scalable-machine-learning-at-cloudflare/](https://blog.cloudflare.com/scalable-machine-learning-at-cloudflare/)
24. Why is a named pipe as slow as writing to a file? \- Unix & Linux Stack
    Exchange, accessed December 25, 2025,
    [https://unix.stackexchange.com/questions/173694/why-is-a-named-pipe-as-slow-as-writing-to-a-file](https://unix.stackexchange.com/questions/173694/why-is-a-named-pipe-as-slow-as-writing-to-a-file)
25. A Year Later, Interlock Ransomware Keeps Leveling Up \- Forescout, accessed
    December 25, 2025,
    [https://www.forescout.com/blog/a-year-later-interlock-ransomware-keeps-leveling-up/](https://www.forescout.com/blog/a-year-later-interlock-ransomware-keeps-leveling-up/)
26. Malware Analysis Techniques : Tricks for the triage of adversarial software,
    accessed December 25, 2025,
    [https://www.asau.ru/files/pdf/2937321.pdf](https://www.asau.ru/files/pdf/2937321.pdf)
27. PowerShell Keylogging Script | Elastic Security \[8.19\], accessed December
    25, 2025,
    [https://www.elastic.co/guide/en/security/8.19/powershell-keylogging-script.html](https://www.elastic.co/guide/en/security/8.19/powershell-keylogging-script.html)
28. relationships, accessed December 25, 2025,
    [https://attack.mitre.org/docs/attack-excel-files/v11.3/enterprise-attack/enterprise-attack-v11.3-relationships.xlsx](https://attack.mitre.org/docs/attack-excel-files/v11.3/enterprise-attack/enterprise-attack-v11.3-relationships.xlsx)
29. Deep Hooks: Monitoring native execution in WoW64 applications – Part 3 \-
    SentinelOne, accessed December 25, 2025,
    [https://www.sentinelone.com/blog/deep-hooks-monitoring-native-execution-wow64-applications-part-3/](https://www.sentinelone.com/blog/deep-hooks-monitoring-native-execution-wow64-applications-part-3/)
30. Code Signing Best Practices \- GlobalSign Support, accessed December 25,
    2025,
    [https://support.globalsign.com/code-signing/general-information/code-signing-best-practices](https://support.globalsign.com/code-signing/general-information/code-signing-best-practices)
31. Code Signing Best Practices For Security | Sectigo® Official, accessed
    December 25, 2025,
    [https://www.sectigo.com/blog/code-signing-best-practices](https://www.sectigo.com/blog/code-signing-best-practices)
32. Working with AppLocker rules \- Microsoft Learn, accessed December 25, 2025,
    [https://learn.microsoft.com/en-us/windows/security/application-security/application-control/app-control-for-business/applocker/working-with-applocker-rules](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/app-control-for-business/applocker/working-with-applocker-rules)
33. Understanding the publisher rule condition in AppLocker \- Microsoft Learn,
    accessed December 25, 2025,
    [https://learn.microsoft.com/en-us/windows/security/application-security/application-control/app-control-for-business/applocker/understanding-the-publisher-rule-condition-in-applocker](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/app-control-for-business/applocker/understanding-the-publisher-rule-condition-in-applocker)
34. Grab raw keyboard inputs : r/rust \- Reddit, accessed December 25, 2025,
    [https://www.reddit.com/r/rust/comments/utbw7t/grab_raw_keyboard_inputs/](https://www.reddit.com/r/rust/comments/utbw7t/grab_raw_keyboard_inputs/)
35. dxgi-capture-rs 1.1.7 \- Docs.rs, accessed December 25, 2025,
    [https://docs.rs/crate/dxgi-capture-rs/latest](https://docs.rs/crate/dxgi-capture-rs/latest)
36. win_desktop_duplication \- crates.io: Rust Package Registry, accessed
    December 25, 2025,
    [https://crates.io/crates/win_desktop_duplication](https://crates.io/crates/win_desktop_duplication)
37. Windows OCR Engine vs Tesseract: A Detailed Comparison \- Iron Software,
    accessed December 25, 2025,
    [https://ironsoftware.com/csharp/ocr/blog/ocr-tools/windows-ocr-engine-vs-tesseract/](https://ironsoftware.com/csharp/ocr/blog/ocr-tools/windows-ocr-engine-vs-tesseract/)
38. \[P\] Choosing an OCR : r/MachineLearning \- Reddit, accessed December 25,
    2025,
    [https://www.reddit.com/r/MachineLearning/comments/i98wr6/p_choosing_an_ocr/](https://www.reddit.com/r/MachineLearning/comments/i98wr6/p_choosing_an_ocr/)
39. winocr \- crates.io: Rust Package Registry, accessed December 25, 2025,
    [https://crates.io/crates/winocr](https://crates.io/crates/winocr)
40. Windows Dev Environment | PDF \- Scribd, accessed December 25, 2025,
    [https://www.scribd.com/document/733463646/Windows-Dev-Environment](https://www.scribd.com/document/733463646/Windows-Dev-Environment)
41. Studio \- Coded Workflow, accessed December 25, 2025,
    [https://docs.uipath.com/studio/standalone/2023.10/user-guide/coded-workflow](https://docs.uipath.com/studio/standalone/2023.10/user-guide/coded-workflow)
42. Your XAML Solutions for most common issues (WIKI POST, anyone can edit),
    accessed December 25, 2025,
    [https://forum.uipath.com/t/your-xaml-solutions-for-most-common-issues-wiki-post-anyone-can-edit/108894](https://forum.uipath.com/t/your-xaml-solutions-for-most-common-issues-wiki-post-anyone-can-edit/108894)
43. Playwright is a framework for Web Testing and Automation. It allows testing
    Chromium, Firefox and WebKit with a single API. \- GitHub, accessed December
    25, 2025,
    [https://github.com/microsoft/playwright](https://github.com/microsoft/playwright)
44. Playwright Selectors: Types \- BrowserStack, accessed December 25, 2025,
    [https://www.browserstack.com/guide/playwright-selectors](https://www.browserstack.com/guide/playwright-selectors)
